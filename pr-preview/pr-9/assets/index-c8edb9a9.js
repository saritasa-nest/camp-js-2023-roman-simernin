var S=Object.defineProperty;var w=(r,e,t)=>e in r?S(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var i=(r,e,t)=>(w(r,typeof e!="symbol"?e+"":e,t),t);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))o(s);new MutationObserver(s=>{for(const n of s)if(n.type==="childList")for(const a of n.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&o(a)}).observe(document,{childList:!0,subtree:!0});function t(s){const n={};return s.integrity&&(n.integrity=s.integrity),s.referrerPolicy&&(n.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?n.credentials="include":s.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function o(s){if(s.ep)return;s.ep=!0;const n=t(s);fetch(s.href,n)}})();class v{constructor(e){i(this,"currentIndex",-1);this.players=e}get passedPlayerIndexes(){return this.players.filter(e=>e.passStatus).map(e=>this.players.indexOf(e))}get hasActivePlayers(){return this.passedPlayerIndexes.length!==this.players.length}next(){return this.hasActivePlayers?(this.currentIndex++,this.currentIndex===this.players.length&&(this.currentIndex=0),this.passedPlayerIndexes.includes(this.currentIndex)&&this.next(),{done:!1,value:this.players[this.currentIndex]}):{done:!1,value:null}}[Symbol.iterator](){return this}}class E{constructor(e,t){i(this,"_isEnd",!1);i(this,"allPlayers");i(this,"activePlayers");if(this.dice=t,e.length===0)throw new Error("Player count can not be zero");this.allPlayers=e,this.activePlayers=new v(e)}get isEnd(){return this._isEnd}rollDice(){if(this.isEnd)throw new Error("Can not roll dice because game ended");const e=this.activePlayers.next();if(e.done||e.value===null)throw new Error("Can not roll dice without active players");const t=e.value;this.dice.roll(),t.addPoints(this.dice.currentSide)}pass(){if(this.isEnd)throw new Error("Can not make a pass because game ended");const e=this.activePlayers.next();if(e.done||e.value===null)throw new Error("Can not make a pass without active players");e.value.pass(),this.activePlayers.hasActivePlayers||this.endGame()}endGame(){const t=this.allPlayers.map(s=>s.totalPoints).filter(s=>s>0&&s<=21);if(t.length!==0){const s=Math.max(...t);for(const n of this.allPlayers)n.setWinStatus(n.totalPoints===s)}else for(const s of this.allPlayers)s.setWinStatus(!1);this._isEnd=!0}}class g{constructor(e){i(this,"_sidesCount");i(this,"_currentSide");if(e<=0)throw new Error("Side count can not be equal or less then zero");this._sidesCount=e}get currentSide(){if(this._currentSide===void 0)throw new Error("Current is not defined, need to roll before");return this._currentSide}roll(){this._currentSide=this.getRandomNumber(this._sidesCount)}getRandomNumber(e){return Math.floor(Math.random()*e)+1}}class _{constructor(e){i(this,"_lastPoints",0);i(this,"_totalPoints",0);i(this,"_winStatus");i(this,"_passStatus",!1);this.name=e}get lastPoints(){return this._lastPoints}get totalPoints(){return this._totalPoints}get winStatus(){return this._winStatus}get passStatus(){return this._passStatus}addPoints(e){if(this._passStatus)throw new Error("Can not add points when player make a pass");if(e<=0)throw new Error("Can not add zero or less points");this._lastPoints=e,this._totalPoints+=e}setWinStatus(e){if(this._winStatus!==void 0)throw new Error("Win status has already defined.");this._winStatus=e}pass(){this._passStatus=!0}}class x{constructor(e){this.dice=e}get currentSide(){return this.dice.currentSide}roll(){this.dice.roll()}}class p{constructor(e){i(this,"subscribers",[]);this.provider=e}subscribe(e){if(this.subscribers.includes(e))throw new Error("Subscriber has already existed.");this.subscribers.push(e)}unsubscribe(e){const t=this.subscribers.indexOf(e);if(t===-1)throw new Error("Subscriber does not exist.");this.subscribers.splice(t,1)}notify(){for(const e of this.subscribers)e.update(this.provider())}}class I extends x{constructor(t){super(t);i(this,"providedPublisher");this.providedPublisher=new p(()=>({currentSide:t.currentSide}))}roll(){super.roll(),this.providedPublisher.notify()}subscribe(t){this.providedPublisher.subscribe(t)}unsubscribe(t){this.providedPublisher.unsubscribe(t)}notify(){this.providedPublisher.notify()}}class P{constructor(e){this.player=e}get name(){return this.player.name}get lastPoints(){return this.player.lastPoints}get totalPoints(){return this.player.totalPoints}get winStatus(){return this.player.winStatus}get passStatus(){return this.player.passStatus}addPoints(e){this.player.addPoints(e)}setWinStatus(e){this.player.setWinStatus(e)}pass(){this.player.pass()}}class k extends P{constructor(t){super(t);i(this,"providedPublisher");this.providedPublisher=new p(()=>({playerName:t.name,points:t.lastPoints}))}addPoints(t){super.addPoints(t),this.providedPublisher.notify()}subscribe(t){this.providedPublisher.subscribe(t)}unsubscribe(t){this.providedPublisher.unsubscribe(t)}notify(){this.providedPublisher.notify()}}class C extends P{constructor(t){super(t);i(this,"providedPublisher");this.providedPublisher=new p(()=>{if(t.winStatus===void 0)throw new Error("Play win status is not defined");return{playerName:t.name,winStatus:t.winStatus}})}setWinStatus(t){super.setWinStatus(t),this.providedPublisher.notify()}subscribe(t){this.providedPublisher.subscribe(t)}unsubscribe(t){this.providedPublisher.unsubscribe(t)}notify(){this.providedPublisher.notify()}}function W(r){const e=new g(r.diceSideCount),t=new I(e);t.subscribe(r.currentDiceSideSubscriber);const o=[],s=[];for(const l of r.playerNames){const f=new _(l),c=new k(f);c.subscribe(r.playerPointsSubscriber),s.push(()=>c.unsubscribe(r.playerPointsSubscriber));const u=new C(c);u.subscribe(r.playerWinStatusSubscriber),s.push(()=>u.unsubscribe(r.playerWinStatusSubscriber)),o.push(u)}return{blackjackInstanse:new E(o,t),clearSubscriptions:()=>{t.unsubscribe(r.currentDiceSideSubscriber);for(const l of s)l()}}}function y(r){const e=document.createElement("li");return e.textContent=r.toString(),e.classList.add("points-container__points-item"),e}class L{constructor(){i(this,"dicePointsSum",0)}update(e){this.dicePointsSum+=e.currentSide,this.presentUpdatedPointSum(this.dicePointsSum),this.presentAppendedPoints(e.currentSide)}presentUpdatedPointSum(e){const t=document.getElementById("dice-points-sum");if(t===null)throw new Error("Dice points sum element is missed");t.textContent=e.toString()}presentAppendedPoints(e){const t=y(e),o=document.getElementById("dice-points-list");if(o===null)throw new Error("Dice points list element is missed");o.appendChild(t)}}class N{constructor(){i(this,"playerPointsSums",new Map)}update(e){let t=this.playerPointsSums.get(e.playerName);t=t===void 0?e.points:t+e.points,this.playerPointsSums.set(e.playerName,t),this.presentUpdatedPointSum(e.playerName,t),this.presentAppendedPoints(e.playerName,e.points)}presentUpdatedPointSum(e,t){const o=document.getElementById(`${e}-points-sum`);if(o===null)throw new Error("Player points sum element is missed");o.textContent=t.toString()}presentAppendedPoints(e,t){const o=y(t),s=document.getElementById(`${e}-points-list`);if(s===null)throw new Error("Player points list element is missed");s.appendChild(o)}}class D{update(e){const t=document.getElementById(`${e.playerName}-points-container`);if(t===null)throw new Error("Player points container element is missed");e.winStatus?t.classList.add("gamer-points-container_winner"):t.classList.add("gamer-points-container_looser")}}const m=W({diceSideCount:6,playerNames:["computer","self"],currentDiceSideSubscriber:new L,playerPointsSubscriber:new N,playerWinStatusSubscriber:new D}),d=m.blackjackInstanse,b=document.getElementById("roll-button"),h=document.getElementById("pass-button");if(b===null)throw new Error("Roll button is missed.");if(h===null)throw new Error("Pass button is missed.");b.addEventListener("click",()=>{d.rollDice()});h.addEventListener("click",()=>{d.pass(),d.isEnd&&(m.clearSubscriptions(),b.classList.add("blackjack-actions-container__action--game-ended"),h.classList.add("blackjack-actions-container__action--game-ended"))});
