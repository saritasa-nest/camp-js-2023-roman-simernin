var v=Object.defineProperty;var g=(i,t,e)=>t in i?v(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var n=(i,t,e)=>(g(i,typeof t!="symbol"?t+"":t,e),e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))a(s);new MutationObserver(s=>{for(const r of s)if(r.type==="childList")for(const o of r.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&a(o)}).observe(document,{childList:!0,subtree:!0});function e(s){const r={};return s.integrity&&(r.integrity=s.integrity),s.referrerPolicy&&(r.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?r.credentials="include":s.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function a(s){if(s.ep)return;s.ep=!0;const r=e(s);fetch(s.href,r)}})();class w{constructor(t){n(this,"players");n(this,"currentIdex",-1);this.players=t}get passedPlayerIndexes(){return this.players.filter(t=>t.passStatus).map(t=>this.players.indexOf(t))}get activePlayersEnded(){return this.passedPlayerIndexes.length==this.players.length}next(){return this.activePlayersEnded?{done:!1,value:null}:(this.currentIdex++,this.currentIdex==this.players.length&&(this.currentIdex=0),this.passedPlayerIndexes.includes(this.currentIdex)&&this.next(),{done:!1,value:this.players[this.currentIdex]})}[Symbol.iterator](){return this}}class E{constructor(t,e){n(this,"gameEndedValue",!1);n(this,"dice");n(this,"allPlayers");n(this,"activePlayers");if(e.length===0)throw"Player count can not be zero";this.dice=t,this.allPlayers=e,this.activePlayers=new w(e)}get gameEnded(){return this.gameEndedValue}rollDice(){if(this.gameEndedValue)throw"Can not roll dice because game ended";const t=this.activePlayers.next();if(t.done||t.value===null)throw"Can not roll dice without active players";const e=t.value;this.dice.roll(),e.addPoints(this.dice.currentSide)}pass(){if(this.gameEndedValue)throw"Can not make a pass because game ended";const t=this.activePlayers.next();if(t.done||t.value===null)throw"Can not make a pass without active players";t.value.pass(),this.activePlayers.activePlayersEnded&&this.endGame()}endGame(){const e=this.allPlayers.map(s=>s.totalPoints).filter(s=>s>0&&s<=21);if(e.length===0)for(const s of this.allPlayers)s.winStatus=!1;else{const s=Math.max(...e);for(const r of this.allPlayers)r.totalPoints===s?r.winStatus=!0:r.winStatus=!1}this.gameEndedValue=!0}}class P{constructor(){n(this,"sidesCountValue",6);n(this,"currentSideValue")}set sideCount(t){if(t<=0)throw"Side count can not be equal or less then zero";this.sidesCountValue=t}get currentSide(){if(this.currentSideValue===void 0)throw"Current is not defined, need to roll before";return this.currentSideValue}roll(){this.currentSideValue=this.getRandomNumber(this.sidesCountValue)}getRandomNumber(t){return Math.floor(Math.random()*t)+1}}class y{constructor(){n(this,"nameValue","no name");n(this,"lastPointsValue",0);n(this,"totalPointsValue",0);n(this,"winStatusValue");n(this,"passStatusValue",!1)}set name(t){this.nameValue=t}get name(){return this.nameValue}get lastPoints(){return this.lastPointsValue}get totalPoints(){return this.totalPointsValue}set winStatus(t){this.winStatusValue=t}get winStatus(){return this.winStatusValue}get passStatus(){return this.passStatusValue}addPoints(t){if(this.passStatusValue)throw"Can not add points when player make a pass";if(t<=0)throw"Can not add zero or less points";this.lastPointsValue=t,this.totalPointsValue+=t}pass(){this.passStatusValue=!0}}class p{constructor(t){n(this,"provider");n(this,"subscribers",[]);this.provider=t}subscribe(t){if(this.subscribers.includes(t))return console.log("Subject: Observer has been attached already.");this.subscribers.push(t)}unsubscribe(t){const e=this.subscribers.indexOf(t);if(e===-1)return console.log("Subject: Nonexistent observer.");this.subscribers.splice(e,1)}notify(){for(let t of this.subscribers)t.update(this.provider())}}class x extends P{constructor(e){super();n(this,"dice");this.dice=e}set sideCount(e){this.dice.sideCount=e}get currentSide(){return this.dice.currentSide}roll(){this.dice.roll()}}class V extends x{constructor(e){super(e);n(this,"providedPublisher");this.providedPublisher=new p(()=>({currentSide:e.currentSide}))}roll(){super.roll(),this.providedPublisher.notify()}subscribe(e){this.providedPublisher.subscribe(e)}unsubscribe(e){this.providedPublisher.unsubscribe(e)}notify(){this.providedPublisher.notify()}}class m extends y{constructor(e){super();n(this,"player");this.player=e}set name(e){this.player.name=e}get name(){return this.player.name}get lastPoints(){return this.player.lastPoints}get totalPoints(){return this.player.totalPoints}set winStatus(e){this.player.winStatus=e}get winStatus(){return this.player.winStatus}get passStatus(){return this.player.passStatus}addPoints(e){this.player.addPoints(e)}pass(){this.player.pass()}}class C extends m{constructor(e){super(e);n(this,"providedPublisher");this.providedPublisher=new p(()=>({playerName:e.name,points:e.lastPoints}))}addPoints(e){super.addPoints(e),this.providedPublisher.notify()}subscribe(e){this.providedPublisher.subscribe(e)}unsubscribe(e){this.providedPublisher.unsubscribe(e)}notify(){this.providedPublisher.notify()}}class k extends m{constructor(e){super(e);n(this,"providedPublisher");this.providedPublisher=new p(()=>{if(e.winStatus===void 0)throw"Play win status is not defined";return{playerName:e.name,winStatus:e.winStatus}})}set winStatus(e){super.winStatus=e,this.providedPublisher.notify()}subscribe(e){this.providedPublisher.subscribe(e)}unsubscribe(e){this.providedPublisher.unsubscribe(e)}notify(){this.providedPublisher.notify()}}function I(i){let t=new P;const e=new V(t);e.subscribe(i.currentDiceSideSubscriber),t=e;const a=[],s=[];for(const l of i.playerNames){const h=new y;h.name=l;const u=new C(h);u.subscribe(i.playerPointsSubscriber),s.push(()=>u.unsubscribe(i.playerPointsSubscriber));const c=new k(u);c.subscribe(i.playerWinStatusSubscriber),s.push(()=>c.unsubscribe(i.playerWinStatusSubscriber)),a.push(c)}return{blackjackInstanse:new E(t,a),clearSubscriptions:()=>{e.unsubscribe(i.currentDiceSideSubscriber);for(const l of s)l()}}}class L{constructor(){n(this,"dicePointsSum",0)}update(t){this.dicePointsSum+=t.currentSide,this.presentUpdatedPointSum(this.dicePointsSum),this.presentAppendedPoints(t.currentSide)}presentUpdatedPointSum(t){const e=document.getElementById("dice-points-sum");e.textContent=t.toString()}presentAppendedPoints(t){const e=document.createElement("li");e.textContent=t.toString(),document.getElementById("dice-points-list").appendChild(e)}}class N{constructor(){n(this,"playerPointsSums",new Map)}update(t){let e=this.playerPointsSums.get(t.playerName);e===void 0?e=t.points:e+=t.points,this.playerPointsSums.set(t.playerName,e),this.presentUpdatedPointSum(t.playerName,e),this.presentAppendedPoints(t.playerName,t.points)}presentUpdatedPointSum(t,e){const a=document.getElementById(`${t}-points-sum`);a.textContent=e.toString()}presentAppendedPoints(t,e){const a=document.createElement("li");a.textContent=e.toString(),document.getElementById(`${t}-points-list`).appendChild(a)}}class j{update(t){const e=document.getElementById(`${t.playerName}-points-container`);t.winStatus===!0?e.classList.add("gamer-points-container--winner"):e.classList.add("gamer-points-container--looser")}}const S=I({diceSideCount:6,playerNames:["computer","self"],currentDiceSideSubscriber:new L,playerPointsSubscriber:new N,playerWinStatusSubscriber:new j}),d=S.blackjackInstanse,f=document.getElementById("roll-button"),b=document.getElementById("pass-button");f.addEventListener("click",function(){d.rollDice()});b.addEventListener("click",function(){d.pass(),d.gameEnded&&(S.clearSubscriptions(),f.classList.add("blackjack-actions-container__action--game-ended"),b.classList.add("blackjack-actions-container__action--game-ended"))});
